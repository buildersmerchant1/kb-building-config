import "./chunk-AAAHXELM.js";
import {
  Color3,
  MaterialDefines,
  MaterialFlags,
  MaterialHelper,
  PushMaterial,
  RegisterClass,
  SerializationHelper,
  ShaderStore,
  Vector3,
  Vector4,
  VertexBuffer,
  __decorate,
  __extends,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-DSA7MM6O.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@babylonjs/materials/grid/grid.fragment.js
var name = "gridPixelShader";
var shader = "#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\nuniform float visibility;\nuniform vec3 mainColor;\nuniform vec3 lineColor;\nuniform vec4 gridControl;\nuniform vec3 gridOffset;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\nfloat getDynamicVisibility(float position) {\nfloat majorGridFrequency=gridControl.y;\nif (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\n{\nreturn 1.0;\n} \nreturn gridControl.z;\n}\nfloat getAnisotropicAttenuation(float differentialLength) {\nconst float maxNumberOfLines=10.0;\nreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\n}\nfloat isPointOnLine(float position,float differentialLength) {\nfloat fractionPartOfPosition=position-floor(position+0.5); \nfractionPartOfPosition/=differentialLength; \nfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\nfloat result=0.5+0.5*cos(fractionPartOfPosition*PI); \nreturn result; \n}\nfloat contributionOnAxis(float position) {\nfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\ndifferentialLength*=SQRT2; \nfloat result=isPointOnLine(position,differentialLength);\nfloat dynamicVisibility=getDynamicVisibility(position);\nresult*=dynamicVisibility;\nfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\nresult*=anisotropicAttenuation;\nreturn result;\n}\nfloat normalImpactOnAxis(float x) {\nfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\nreturn normalImpact;\n}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;\nvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\nfloat x=contributionOnAxis(gridPos.x);\nfloat y=contributionOnAxis(gridPos.y);\nfloat z=contributionOnAxis(gridPos.z);\nvec3 normal=normalize(vNormal);\nx*=normalImpactOnAxis(normal.x);\ny*=normalImpactOnAxis(normal.y);\nz*=normalImpactOnAxis(normal.z);\n#ifdef MAX_LINE \nfloat grid=clamp(max(max(x,y),z),0.,1.);\n#else\nfloat grid=clamp(x+y+z,0.,1.);\n#endif\nvec3 color=mix(mainColor,lineColor,grid);\n#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\n#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\n#endif \n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\n#endif \ngl_FragColor=vec4(color.rgb,opacity*visibility);\n#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\n#endif\n#else \n#endif\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/materials/grid/grid.vertex.js
var name2 = "gridVertexShader";
var shader2 = "precision highp float;\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#include<instancesDeclaration>\nuniform mat4 projection;\nuniform mat4 view;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;\ngl_Position=projection*cameraSpacePosition;\n#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\nif (vOpacityInfos.x==0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif \nvPosition=position;\nvNormal=normal;\n#define CUSTOM_VERTEX_MAIN_END\n}";
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/materials/grid/gridMaterial.js
var GridMaterialDefines = function(_super) {
  __extends(GridMaterialDefines2, _super);
  function GridMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.OPACITY = false;
    _this.TRANSPARENT = false;
    _this.FOG = false;
    _this.PREMULTIPLYALPHA = false;
    _this.MAX_LINE = false;
    _this.UV1 = false;
    _this.UV2 = false;
    _this.INSTANCES = false;
    _this.THIN_INSTANCES = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.SKIPFINALCOLORCLAMP = false;
    _this.rebuild();
    return _this;
  }
  return GridMaterialDefines2;
}(MaterialDefines);
var GridMaterial = function(_super) {
  __extends(GridMaterial2, _super);
  function GridMaterial2(name3, scene) {
    var _this = _super.call(this, name3, scene) || this;
    _this.mainColor = Color3.Black();
    _this.lineColor = Color3.Teal();
    _this.gridRatio = 1;
    _this.gridOffset = Vector3.Zero();
    _this.majorUnitFrequency = 10;
    _this.minorUnitVisibility = 0.33;
    _this.opacity = 1;
    _this.preMultiplyAlpha = false;
    _this.useMaxLine = false;
    _this._gridControl = new Vector4(_this.gridRatio, _this.majorUnitFrequency, _this.minorUnitVisibility, _this.opacity);
    return _this;
  }
  GridMaterial2.prototype.needAlphaBlending = function() {
    return this.opacity < 1 || this._opacityTexture && this._opacityTexture.isReady();
  };
  GridMaterial2.prototype.needAlphaBlendingForMesh = function(mesh) {
    return mesh.visibility < 1 || this.needAlphaBlending();
  };
  GridMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    if (this.isFrozen) {
      if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new GridMaterialDefines();
    }
    var defines = subMesh.materialDefines;
    var scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    if (defines.TRANSPARENT !== this.opacity < 1) {
      defines.TRANSPARENT = !defines.TRANSPARENT;
      defines.markAsUnprocessed();
    }
    if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {
      defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;
      defines.markAsUnprocessed();
    }
    if (defines.MAX_LINE !== this.useMaxLine) {
      defines.MAX_LINE = !defines.MAX_LINE;
      defines.markAsUnprocessed();
    }
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.OPACITY = true;
          }
        }
      }
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), defines, !!useInstances);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);
      var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      var join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect("grid", attribs, [
        "projection",
        "mainColor",
        "lineColor",
        "gridControl",
        "gridOffset",
        "vFogInfos",
        "vFogColor",
        "world",
        "view",
        "opacityMatrix",
        "vOpacityInfos",
        "visibility"
      ], ["opacitySampler"], join, void 0, this.onCompiled, this.onError), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  };
  GridMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this._activeEffect.setFloat("visibility", mesh.visibility);
    if (!defines.INSTANCES || defines.THIN_INSTANCE) {
      this.bindOnlyWorldMatrix(world);
    }
    this._activeEffect.setMatrix("view", scene.getViewMatrix());
    this._activeEffect.setMatrix("projection", scene.getProjectionMatrix());
    if (this._mustRebind(scene, effect)) {
      this._activeEffect.setColor3("mainColor", this.mainColor);
      this._activeEffect.setColor3("lineColor", this.lineColor);
      this._activeEffect.setVector3("gridOffset", this.gridOffset);
      this._gridControl.x = this.gridRatio;
      this._gridControl.y = Math.round(this.majorUnitFrequency);
      this._gridControl.z = this.minorUnitVisibility;
      this._gridControl.w = this.opacity;
      this._activeEffect.setVector4("gridControl", this._gridControl);
      if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
        this._activeEffect.setTexture("opacitySampler", this._opacityTexture);
        this._activeEffect.setFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
        this._activeEffect.setMatrix("opacityMatrix", this._opacityTexture.getTextureMatrix());
      }
    }
    MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect);
  };
  GridMaterial2.prototype.dispose = function(forceDisposeEffect) {
    _super.prototype.dispose.call(this, forceDisposeEffect);
  };
  GridMaterial2.prototype.clone = function(name3) {
    var _this = this;
    return SerializationHelper.Clone(function() {
      return new GridMaterial2(name3, _this.getScene());
    }, this);
  };
  GridMaterial2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.customType = "BABYLON.GridMaterial";
    return serializationObject;
  };
  GridMaterial2.prototype.getClassName = function() {
    return "GridMaterial";
  };
  GridMaterial2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new GridMaterial2(source.name, scene);
    }, source, scene, rootUrl);
  };
  __decorate([
    serializeAsColor3()
  ], GridMaterial2.prototype, "mainColor", void 0);
  __decorate([
    serializeAsColor3()
  ], GridMaterial2.prototype, "lineColor", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "gridRatio", void 0);
  __decorate([
    serializeAsVector3()
  ], GridMaterial2.prototype, "gridOffset", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "majorUnitFrequency", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "minorUnitVisibility", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "opacity", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "preMultiplyAlpha", void 0);
  __decorate([
    serialize()
  ], GridMaterial2.prototype, "useMaxLine", void 0);
  __decorate([
    serializeAsTexture("opacityTexture")
  ], GridMaterial2.prototype, "_opacityTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], GridMaterial2.prototype, "opacityTexture", void 0);
  return GridMaterial2;
}(PushMaterial);
RegisterClass("BABYLON.GridMaterial", GridMaterial);
export {
  GridMaterial
};
//# sourceMappingURL=@babylonjs_materials_grid.js.map
