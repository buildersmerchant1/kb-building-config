{
  "version": 3,
  "sources": ["../../../../lts/materials/generated/grid/grid.fragment.ts", "../../../../lts/materials/generated/grid/grid.vertex.ts", "../../../../lts/materials/generated/grid/gridMaterial.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\runiform float visibility;\runiform vec3 mainColor;\runiform vec3 lineColor;\runiform vec4 gridControl;\runiform vec3 gridOffset;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform sampler2D opacitySampler;\runiform vec2 vOpacityInfos;\r#endif\nfloat getDynamicVisibility(float position) {\rfloat majorGridFrequency=gridControl.y;\rif (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\r{\rreturn 1.0;\r} \rreturn gridControl.z;\r}\rfloat getAnisotropicAttenuation(float differentialLength) {\rconst float maxNumberOfLines=10.0;\rreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\r}\rfloat isPointOnLine(float position,float differentialLength) {\rfloat fractionPartOfPosition=position-floor(position+0.5); \rfractionPartOfPosition/=differentialLength; \rfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\rfloat result=0.5+0.5*cos(fractionPartOfPosition*PI); \rreturn result; \r}\rfloat contributionOnAxis(float position) {\rfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\rdifferentialLength*=SQRT2; \rfloat result=isPointOnLine(position,differentialLength);\rfloat dynamicVisibility=getDynamicVisibility(position);\rresult*=dynamicVisibility;\rfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\rresult*=anisotropicAttenuation;\rreturn result;\r}\rfloat normalImpactOnAxis(float x) {\rfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\rreturn normalImpact;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;\rvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\rfloat x=contributionOnAxis(gridPos.x);\rfloat y=contributionOnAxis(gridPos.y);\rfloat z=contributionOnAxis(gridPos.z);\rvec3 normal=normalize(vNormal);\rx*=normalImpactOnAxis(normal.x);\ry*=normalImpactOnAxis(normal.y);\rz*=normalImpactOnAxis(normal.z);\r#ifdef MAX_LINE \nfloat grid=clamp(max(max(x,y),z),0.,1.);\r#else\nfloat grid=clamp(x+y+z,0.,1.);\r#endif\nvec3 color=mix(mainColor,lineColor,grid);\r#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\r#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\r#endif \n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\r#endif \ngl_FragColor=vec4(color.rgb,opacity*visibility);\r#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\r#endif\n#else \n#endif\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const gridPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\n\nconst name = \"gridVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\rattribute vec3 normal;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#include<instancesDeclaration>\nuniform mat4 projection;\runiform mat4 view;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform mat4 opacityMatrix;\runiform vec2 vOpacityInfos;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\r#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;\rgl_Position=projection*cameraSpacePosition;\r#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\nif (vOpacityInfos.x==0.)\r{\rvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\r}\r#endif \nvPosition=position;\rvNormal=normal;\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport const gridVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper, serializeAsVector3 } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector4, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public OPACITY = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public MAX_LINE = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsVector3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    /**\r\n     * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\r\n     */\r\n    @serialize()\r\n    public useMaxLine = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the grid requires alpha blending.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.MAX_LINE !== this.useMaxLine) {\r\n            defines.MAX_LINE = !defines.MAX_LINE;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Defines\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"grid\",\r\n                        attribs,\r\n                        [\r\n                            \"projection\",\r\n                            \"mainColor\",\r\n                            \"lineColor\",\r\n                            \"gridControl\",\r\n                            \"gridOffset\",\r\n                            \"vFogInfos\",\r\n                            \"vFogColor\",\r\n                            \"world\",\r\n                            \"view\",\r\n                            \"opacityMatrix\",\r\n                            \"vOpacityInfos\",\r\n                            \"visibility\",\r\n                        ],\r\n                        [\"opacitySampler\"],\r\n                        join,\r\n                        undefined,\r\n                        this.onCompiled,\r\n                        this.onError\r\n                    ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n        }\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAMA,IAAM,OAAO;AACb,IAAM,SAAS;AA0Ff,YAAY,aAAa,QAAQ;;;AC1FjC,IAAM,QAAO;AACb,IAAM,UAAS;AAiDf,YAAY,aAAa,SAAQ;;;ACrCjC,IAAA,sBAAA,SAAA,QAAA;AAAkC,YAAA,sBAAA,MAAA;AAa9B,kCAAA;AAAA,QAAA,QACI,OAAA,KAAA,IAAA,KAAO;AAbJ,UAAA,UAAU;AACV,UAAA,cAAc;AACd,UAAA,MAAM;AACN,UAAA,mBAAmB;AACnB,UAAA,WAAW;AACX,UAAA,MAAM;AACN,UAAA,MAAM;AACN,UAAA,YAAY;AACZ,UAAA,iBAAiB;AACjB,UAAA,6BAA6B;AAC7B,UAAA,sBAAsB;AAIzB,UAAK,QAAO;;EAChB;AACJ,SAAA;AAAA,EAjBkC,eAAe;AAuBjD,IAAA,eAAA,SAAA,QAAA;AAAkC,YAAA,eAAA,MAAA;AAmE9B,yBAAY,OAAc,OAAa;AAAvC,QAAA,QACI,OAAA,KAAA,MAAM,OAAM,KAAK,KAAC;AA/Df,UAAA,YAAY,OAAO,MAAK;AAMxB,UAAA,YAAY,OAAO,KAAI;AAMvB,UAAA,YAAY;AAMZ,UAAA,aAAa,QAAQ,KAAI;AAMzB,UAAA,qBAAqB;AAMrB,UAAA,sBAAsB;AAMtB,UAAA,UAAU;AAMV,UAAA,mBAAmB;AAMnB,UAAA,aAAa;AAOZ,UAAA,eAAwB,IAAI,QAAQ,MAAK,WAAW,MAAK,oBAAoB,MAAK,qBAAqB,MAAK,OAAO;;EAS3H;AAKO,gBAAA,UAAA,oBAAP,WAAA;AACI,WAAO,KAAK,UAAU,KAAQ,KAAK,mBAAmB,KAAK,gBAAgB,QAAO;EACtF;AAEO,gBAAA,UAAA,2BAAP,SAAgC,MAAkB;AAC9C,WAAO,KAAK,aAAa,KAAO,KAAK,kBAAiB;EAC1D;AAEO,gBAAA,UAAA,oBAAP,SAAyB,MAAoB,SAAkB,cAAsB;AACjF,QAAI,KAAK,UAAU;AACf,UAAI,QAAQ,UAAU,QAAQ,OAAO,uBAAuB,QAAQ,OAAO,iCAAiC,cAAc;AACtH,eAAO;;;AAIf,QAAI,CAAC,QAAQ,iBAAiB;AAC1B,cAAQ,kBAAkB,IAAI,oBAAmB;;AAGrD,QAAM,UAA+B,QAAQ;AAC7C,QAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAI,KAAK,mBAAmB,OAAO,GAAG;AAClC,aAAO;;AAGX,QAAI,QAAQ,gBAAgB,KAAK,UAAU,GAAK;AAC5C,cAAQ,cAAc,CAAC,QAAQ;AAC/B,cAAQ,kBAAiB;;AAG7B,QAAI,QAAQ,oBAAoB,KAAK,kBAAkB;AACnD,cAAQ,mBAAmB,CAAC,QAAQ;AACpC,cAAQ,kBAAiB;;AAG7B,QAAI,QAAQ,aAAa,KAAK,YAAY;AACtC,cAAQ,WAAW,CAAC,QAAQ;AAC5B,cAAQ,kBAAiB;;AAI7B,QAAI,QAAQ,mBAAmB;AAC3B,cAAQ,WAAW;AACnB,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,cAAI,CAAC,KAAK,gBAAgB,QAAO,GAAI;AACjC,mBAAO;iBACJ;AACH,oBAAQ,WAAW;AACnB,oBAAQ,UAAU;;;;;AAMlC,mBAAe,sBAAsB,MAAM,OAAO,OAAO,OAAO,KAAK,YAAY,OAAO,OAAO;AAG/F,mBAAe,kCAAkC,OAAO,MAAM,UAAS,GAAI,SAAS,CAAC,CAAC,YAAY;AAGlG,QAAI,QAAQ,SAAS;AACjB,cAAQ,gBAAe;AACvB,YAAM,oBAAmB;AAGzB,qBAAe,4BAA4B,MAAM,SAAS,OAAO,KAAK;AACtE,UAAM,UAAU,CAAC,aAAa,cAAc,aAAa,UAAU;AAEnE,UAAI,QAAQ,KAAK;AACb,gBAAQ,KAAK,aAAa,MAAM;;AAEpC,UAAI,QAAQ,KAAK;AACb,gBAAQ,KAAK,aAAa,OAAO;;AAGrC,cAAQ,6BAA6B,MAAM,6BAA6B;AAExE,qBAAe,8BAA8B,SAAS,OAAO;AAG7D,UAAM,OAAO,QAAQ,SAAQ;AAC7B,cAAQ,UACJ,MACK,UAAS,EACT,aACG,QACA,SACA;QACI;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;SAEJ,CAAC,gBAAgB,GACjB,MACA,QACA,KAAK,YACL,KAAK,OAAO,GAEpB,SACA,KAAK,gBAAgB;;AAI7B,QAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,OAAO,QAAO,GAAI;AAC9C,aAAO;;AAGX,YAAQ,YAAY,MAAM,YAAW;AACrC,YAAQ,OAAO,sBAAsB;AACrC,YAAQ,OAAO,+BAA+B,CAAC,CAAC;AAEhD,WAAO;EACX;AAEO,gBAAA,UAAA,iBAAP,SAAsB,OAAe,MAAY,SAAgB;AAC7D,QAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAM,UAA+B,QAAQ;AAC7C,QAAI,CAAC,SAAS;AACV;;AAGJ,QAAM,SAAS,QAAQ;AACvB,QAAI,CAAC,QAAQ;AACT;;AAEJ,SAAK,gBAAgB;AAErB,SAAK,cAAc,SAAS,cAAc,KAAK,UAAU;AAGzD,QAAI,CAAC,QAAQ,aAAa,QAAQ,eAAe;AAC7C,WAAK,oBAAoB,KAAK;;AAElC,SAAK,cAAc,UAAU,QAAQ,MAAM,cAAa,CAAE;AAC1D,SAAK,cAAc,UAAU,cAAc,MAAM,oBAAmB,CAAE;AAGtE,QAAI,KAAK,YAAY,OAAO,MAAM,GAAG;AACjC,WAAK,cAAc,UAAU,aAAa,KAAK,SAAS;AACxD,WAAK,cAAc,UAAU,aAAa,KAAK,SAAS;AAExD,WAAK,cAAc,WAAW,cAAc,KAAK,UAAU;AAE3D,WAAK,aAAa,IAAI,KAAK;AAC3B,WAAK,aAAa,IAAI,KAAK,MAAM,KAAK,kBAAkB;AACxD,WAAK,aAAa,IAAI,KAAK;AAC3B,WAAK,aAAa,IAAI,KAAK;AAC3B,WAAK,cAAc,WAAW,eAAe,KAAK,YAAY;AAE9D,UAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,aAAK,cAAc,WAAW,kBAAkB,KAAK,eAAe;AACpE,aAAK,cAAc,UAAU,iBAAiB,KAAK,gBAAgB,kBAAkB,KAAK,gBAAgB,KAAK;AAC/G,aAAK,cAAc,UAAU,iBAAiB,KAAK,gBAAgB,iBAAgB,CAAE;;;AAI7F,mBAAe,kBAAkB,OAAO,MAAM,KAAK,aAAa;AAEhE,SAAK,WAAW,MAAM,KAAK,aAAa;EAC5C;AAMO,gBAAA,UAAA,UAAP,SAAe,oBAA4B;AACvC,WAAA,UAAM,QAAO,KAAA,MAAC,kBAAkB;EACpC;AAEO,gBAAA,UAAA,QAAP,SAAa,OAAY;AAAzB,QAAA,QAAA;AACI,WAAO,oBAAoB,MAAM,WAAA;AAAM,aAAA,IAAI,cAAa,OAAM,MAAK,SAAQ,CAAE;IAAtC,GAAyC,IAAI;EACxF;AAEO,gBAAA,UAAA,YAAP,WAAA;AACI,QAAM,sBAAsB,OAAA,UAAM,UAAS,KAAA,IAAA;AAC3C,wBAAoB,aAAa;AACjC,WAAO;EACX;AAEO,gBAAA,UAAA,eAAP,WAAA;AACI,WAAO;EACX;AAEc,gBAAA,QAAd,SAAoB,QAAa,OAAc,SAAe;AAC1D,WAAO,oBAAoB,MAAM,WAAA;AAAM,aAAA,IAAI,cAAa,OAAO,MAAM,KAAK;IAAnC,GAAsC,QAAQ,OAAO,OAAO;EACvG;AA1QA,aAAA;IADC,kBAAiB;;AAOlB,aAAA;IADC,kBAAiB;;AAOlB,aAAA;IADC,UAAS;;AAOV,aAAA;IADC,mBAAkB;;AAOnB,aAAA;IADC,UAAS;;AAOV,aAAA;IADC,UAAS;;AAOV,aAAA;IADC,UAAS;;AAOV,aAAA;IADC,UAAS;;AAOV,aAAA;IADC,UAAS;;AAIV,aAAA;IADC,mBAAmB,gBAAgB;;AAGpC,aAAA;IADC,iBAAiB,kCAAkC;;AAuNxD,SAAA;EAhRkC,YAAY;AAkR9C,cAAc,wBAAwB,YAAY;",
  "names": []
}
